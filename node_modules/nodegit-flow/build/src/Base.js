'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function (NodeGit, _ref, _ref2) {
  var constants = _ref.constants;
  var Config = _ref2.Config,
      Feature = _ref2.Feature,
      Hotfix = _ref2.Hotfix,
      Release = _ref2.Release;

  var GitFlowClasses = [Config, Feature, Hotfix, Release];

  function createFlowInstance(repo) {
    var Flow = {};

    // Magic to keep individual object context when using init methods
    GitFlowClasses.forEach(function (GitFlowClass) {
      var gitflowObject = new GitFlowClass(repo);
      Object.getOwnPropertyNames(GitFlowClass.prototype).forEach(function (propName) {
        if (propName !== 'constructor' && typeof GitFlowClass.prototype[propName] === 'function') {
          Flow[propName] = function () {
            return gitflowObject[propName].apply(gitflowObject, arguments);
          };
        }
      });
    });

    return Flow;
  }

  /**
   * All of this class' functions are attached to `NodeGit.Flow`
   * @class
   */

  var Base = function () {
    function Base() {
      _classCallCheck(this, Base);
    }

    _createClass(Base, null, [{
      key: 'developBranchExists',

      /**
       * Check if the repo is initialized with git flow and its develop branch exists
       * @async
       * @param {Repository}  repo  The nodegit repository instance to check
       * @return {Boolean} Whether or not the develop branch as specified in the git config exists
       */
      value: function developBranchExists(repo) {
        if (!repo) {
          return Promise.reject(new Error(constants.ErrorMessage.REPO_REQUIRED));
        }

        return this.isInitialized(repo).then(function (isInitialized) {
          if (!isInitialized) {
            return Promise.reject(new Error(constants.ErrorMessage.GIT_FLOW_NOT_INITIALIZED));
          }

          return repo.config().then(function (config) {
            return config.getString('gitflow.branch.develop');
          }).then(function (developBranchName) {
            return NodeGit.Branch.lookup(repo, developBranchName, NodeGit.Branch.BRANCH.LOCAL);
          }).then(function () {
            return true;
          }).catch(function () {
            return false;
          });
        });
      }

      /**
       * Initializes the repo to use git flow
       * @async
       * @param {Repository}  repo            The repository to initialize git flow in
       * @param {Object}      gitflowConfig   The git flow configuration to use
       * @return {Flow} An instance of a flow object tied to the repository
       */

    }, {
      key: 'init',
      value: function init(repo, gitflowConfig) {
        if (!repo) {
          return Promise.reject(new Error(constants.ErrorMessage.REPO_REQUIRED));
        }

        gitflowConfig = gitflowConfig || {};

        var defaultConfig = Config.getConfigDefault();
        var configKeys = Object.keys(defaultConfig);
        var configToUse = {};

        // filter out non-gitflow keys
        configKeys.forEach(function (key) {
          configToUse[key] = gitflowConfig[key];
        });

        var configError = Config.validateConfig(configToUse);
        if (configError) {
          return Promise.reject(new Error(configError));
        }

        var masterBranchName = configToUse['gitflow.branch.master'];
        var developBranchName = configToUse['gitflow.branch.develop'];

        return NodeGit.Branch.lookup(repo, masterBranchName, NodeGit.Branch.BRANCH.LOCAL).catch(function () {
          return Promise.reject(new Error('The branch set as the `master` branch must already exist locally'));
        }).then(function () {
          // Create the `develop` branch if it does not already exist
          return NodeGit.Branch.lookup(repo, developBranchName, NodeGit.Branch.BRANCH.LOCAL).catch(function () {
            return repo.getBranchCommit('refs/remotes/origin/' + developBranchName).catch(function () {
              return repo.getBranchCommit(masterBranchName);
            }).then(function (commit) {
              return repo.createBranch(developBranchName, commit.id());
            });
          });
        }).then(function () {
          return repo.config();
        }).then(function (config) {
          // Set the config values. We chain them so we don't have concurrent setString calls to the same config file
          return configKeys.reduce(function (last, next) {
            return last.then(function () {
              return config.setString(next, configToUse[next]);
            });
          }, Promise.resolve());
        }).then(function () {
          return createFlowInstance(repo);
        });
      }

      /**
       * Check if the repo is using git flow
       * @async
       * @param {Repository}  repo  The nodegit repository instance to check
       * @return {Boolean} Whether or not the repo has git flow initialized
       */

    }, {
      key: 'isInitialized',
      value: function isInitialized(repo) {
        if (!repo) {
          return Promise.reject(new Error(constants.ErrorMessage.REPO_REQUIRED));
        }

        return repo.config().then(function (config) {
          var promises = Config.getConfigRequiredKeys().map(function (key) {
            return config.getString(key);
          });

          return Promise.all(promises).then(function () {
            return true;
          }).catch(function () {
            return false;
          });
        });
      }

      /**
       * Check if the repo is initialized with git flow and its master branch exists
       * @async
       * @param {Repository}  repo  The nodegit repository instance to check
       * @return {Boolean} Whether or not the master branch as specified in the git config exists
       */

    }, {
      key: 'masterBranchExists',
      value: function masterBranchExists(repo) {
        if (!repo) {
          return Promise.reject(new Error(constants.ErrorMessage.REPO_REQUIRED));
        }

        return Base.isInitialized(repo).then(function (isInitialized) {
          if (!isInitialized) {
            return Promise.reject(new Error(constants.ErrorMessage.GIT_FLOW_NOT_INITIALIZED));
          }

          return repo.config().then(function (config) {
            return config.getString('gitflow.branch.master');
          }).then(function (masterBranchName) {
            return NodeGit.Branch.lookup(repo, masterBranchName, NodeGit.Branch.BRANCH.LOCAL);
          }).then(function () {
            return true;
          }).catch(function () {
            return false;
          });
        });
      }

      /**
       * Creates a Flow instance for a repo that already has git flow initialized
       * @async
       * @param {Repository}  repo  The target nodegit repository
       * @return {Flow} An instance of a flow object tied to the repository
       */

    }, {
      key: 'open',
      value: function open(repo) {
        return Base.isInitialized(repo).then(function (isInitialized) {
          if (!isInitialized) {
            return Promise.reject(new Error('The repository does not have gitflow initialized'));
          }

          return createFlowInstance(repo);
        });
      }
    }]);

    return Base;
  }();

  return Base;
};