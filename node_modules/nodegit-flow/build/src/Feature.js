'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function (NodeGit, _ref, _ref2) {
  var constants = _ref.constants,
      utils = _ref.utils;
  var Config = _ref2.Config;

  /**
   * All of this class' functions are attached to `NodeGit.Flow` or a `Flow` instance object
   * @class
   */
  var Feature = function () {
    function Feature(repo, config) {
      _classCallCheck(this, Feature);

      this.repo = repo;
      this.config = config;
    }

    /**
     * Starts a git flow "feature"
     * @async
     * @param {Object}  repo        The repository to start a feature in
     * @param {String}  featureName The name of the feature to start
     * @param {Object}  options     Options for start feature
     * @return {Branch}   The nodegit branch for the feature
     */


    _createClass(Feature, [{
      key: 'startFeature',


      /**
       * Starts a git flow "feature"
       * @async
       * @param {String}  featureName The name of the feature to start
       * @param {Object}  options     Options for start feature
       * @return {Branch}   The nodegit branch for the feature
       */
      value: function startFeature() {
        return Feature.startFeature.apply(Feature, [this.repo].concat(Array.prototype.slice.call(arguments)));
      }

      /**
       * Finishes a git flow "feature"
       * @async
       * @param {String}  featureName The name of the feature to finish
       * @param {Object}  options     Options for finish feature
       * @return {Commit}   The commit created by finishing the feature
       */

    }, {
      key: 'finishFeature',
      value: function finishFeature() {
        return Feature.finishFeature.apply(Feature, [this.repo].concat(Array.prototype.slice.call(arguments)));
      }
    }], [{
      key: 'startFeature',
      value: function startFeature(repo, featureName) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var sha = options.sha;


        if (!repo) {
          return Promise.reject(new Error(constants.ErrorMessage.REPO_REQUIRED));
        }

        if (!featureName) {
          return Promise.reject(new Error('Feature name is required'));
        }

        var featureBranchName = void 0;
        var featureBranch = void 0;

        return Config.getConfig(repo).then(function (config) {
          var featurePrefix = config['gitflow.prefix.feature'];
          var developBranchName = config['gitflow.branch.develop'];

          featureBranchName = featurePrefix + featureName;
          if (sha) {
            return NodeGit.Commit.lookup(repo, sha);
          }

          return NodeGit.Branch.lookup(repo, developBranchName, NodeGit.Branch.BRANCH.LOCAL).then(function (developBranch) {
            return NodeGit.Commit.lookup(repo, developBranch.target());
          });
        }).then(function (fromCommit) {
          return repo.createBranch(featureBranchName, fromCommit);
        }).then(function (_featureBranch) {
          featureBranch = _featureBranch;
          return repo.checkoutBranch(featureBranch);
        }).then(function () {
          return featureBranch;
        });
      }

      /**
       * Finishes a git flow "feature"
       * @async
       * @param {Object}  repo        The repository to finish a feature in
       * @param {String}  featureName The name of the feature to finish
       * @param {Object}  options     Options for finish feature
       * @return {Commit}   The commit created by finishing the feature
       */

    }, {
      key: 'finishFeature',
      value: function finishFeature(repo, featureName) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var keepBranch = options.keepBranch,
            isRebase = options.isRebase,
            _options$preRebaseCal = options.preRebaseCallback,
            preRebaseCallback = _options$preRebaseCal === undefined ? function () {} : _options$preRebaseCal,
            _options$beforeMergeC = options.beforeMergeCallback,
            beforeMergeCallback = _options$beforeMergeC === undefined ? function () {} : _options$beforeMergeC,
            processMergeMessageCallback = options.processMergeMessageCallback,
            _options$postMergeCal = options.postMergeCallback,
            postMergeCallback = _options$postMergeCal === undefined ? function () {} : _options$postMergeCal,
            _options$beforeRebase = options.beforeRebaseFinishCallback,
            beforeRebaseFinishCallback = _options$beforeRebase === undefined ? function () {} : _options$beforeRebase,
            signingCallback = options.signingCallback;


        if (!repo) {
          return Promise.reject(new Error('Repo is required'));
        }

        if (!featureName) {
          return Promise.reject(new Error('Feature name is required'));
        }

        var developBranch = void 0;
        var featureBranch = void 0;
        var developCommit = void 0;
        var featureCommit = void 0;
        var cancelDevelopMerge = void 0;
        var mergeCommit = void 0;
        var developBranchName = void 0;
        var featureBranchName = void 0;
        return Config.getConfig(repo).then(function (config) {
          developBranchName = config['gitflow.branch.develop'];
          featureBranchName = config['gitflow.prefix.feature'] + featureName;

          return Promise.all([developBranchName, featureBranchName].map(function (branchName) {
            return NodeGit.Branch.lookup(repo, branchName, NodeGit.Branch.BRANCH.LOCAL);
          }));
        }).then(function (branches) {
          developBranch = branches[0];
          featureBranch = branches[1];

          return Promise.all(branches.map(function (branch) {
            return repo.getCommit(branch.target());
          }));
        }).then(function (commits) {
          developCommit = commits[0];
          featureCommit = commits[1];

          // If the develop branch and feautre branch point to the same thing do not merge them
          // or if the `isRebase` parameter is true do not merge
          var isSameCommit = developCommit.id().toString() === featureCommit.id().toString();
          cancelDevelopMerge = isSameCommit || isRebase;

          if (!cancelDevelopMerge) {
            return Promise.resolve(beforeMergeCallback(developBranchName, featureBranchName)).then(function () {
              return utils.Repo.merge(developBranch, featureBranch, repo, processMergeMessageCallback, signingCallback);
            }).then(utils.InjectIntermediateCallback(postMergeCallback));
          } else if (isRebase && !isSameCommit) {
            return Promise.resolve(preRebaseCallback(developBranchName, featureBranchName)).then(function () {
              return utils.Repo.rebase(developBranch, featureBranch, repo, beforeRebaseFinishCallback, signingCallback);
            });
          }
          return Promise.resolve();
        }).then(function (_mergeCommit) {
          mergeCommit = _mergeCommit;
          if (cancelDevelopMerge) {
            return repo.checkoutBranch(developBranch);
          }
          return Promise.resolve();
        }).then(function () {
          if (keepBranch) {
            return Promise.resolve();
          }

          return NodeGit.Branch.lookup(repo, featureBranchName, NodeGit.Branch.BRANCH.LOCAL).then(function (branch) {
            return branch.delete();
          });
        }).then(function () {
          return mergeCommit;
        });
      }
    }]);

    return Feature;
  }();

  return Feature;
};