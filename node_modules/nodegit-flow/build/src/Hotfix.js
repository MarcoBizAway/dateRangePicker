'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function (NodeGit, _ref, _ref2) {
  var constants = _ref.constants,
      utils = _ref.utils;
  var Config = _ref2.Config;

  /**
   * All of this class' functions are attached to `NodeGit.Flow` or a `Flow` instance object
   * @class
   */
  var Hotfix = function () {
    function Hotfix(repo) {
      _classCallCheck(this, Hotfix);

      this.repo = repo;
    }

    /**
     * Starts a git flow "hotfix"
     * @async
     * @param {Object}  repo          The repository to start a hotfix in
     * @param {String}  hotfixVersion The version of the hotfix to start
     * @param {Object}  options       Options for start hotfix
     * @return {Branch}   The nodegit branch for the hotfix
     */


    _createClass(Hotfix, [{
      key: 'startHotfix',


      /**
       * Starts a git flow "hotfix"
       * @async
       * @param {String}  hotfixVersion The version of the hotfix to start
       * @param {Object}  options       Options for start hotfix
       * @return {Branch}   The nodegit branch for the hotfix
       */
      value: function startHotfix() {
        return Hotfix.startHotfix.apply(Hotfix, [this.repo].concat(Array.prototype.slice.call(arguments)));
      }

      /**
       * Finishes a git flow "hotfix"
       * @async
       * @param {String}  hotfixVersion   The version of the hotfix to finish
       * @param {Object}  options         Options for finish hotfix
       * @return {Commit}   The commit created by finishing the hotfix
       */

    }, {
      key: 'finishHotfix',
      value: function finishHotfix() {
        return Hotfix.finishHotfix.apply(Hotfix, [this.repo].concat(Array.prototype.slice.call(arguments)));
      }
    }], [{
      key: 'startHotfix',
      value: function startHotfix(repo, hotfixVersion) {
        if (!repo) {
          return Promise.reject(new Error(constants.ErrorMessage.REPO_REQUIRED));
        }

        if (!hotfixVersion) {
          return Promise.reject(new Error('Hotfix version is required'));
        }

        var hotfixBranchName = void 0;
        var hotfixBranch = void 0;

        return Config.getConfig(repo).then(function (config) {
          var hotfixPrefix = config['gitflow.prefix.hotfix'];
          var masterBranchName = config['gitflow.branch.master'];
          hotfixBranchName = hotfixPrefix + hotfixVersion;

          return NodeGit.Branch.lookup(repo, masterBranchName, NodeGit.Branch.BRANCH.LOCAL);
        }).then(function (masterBranch) {
          return NodeGit.Commit.lookup(repo, masterBranch.target());
        }).then(function (localMasterCommit) {
          return repo.createBranch(hotfixBranchName, localMasterCommit);
        }).then(function (_hotfixBranch) {
          hotfixBranch = _hotfixBranch;
          return repo.checkoutBranch(hotfixBranch);
        }).then(function () {
          return hotfixBranch;
        });
      }

      /**
       * Finishes a git flow "hotfix"
       * @async
       * @param {Object}  repo            The repository to finish a hotfix in
       * @param {String}  hotfixVersion   The version of the hotfix to finish
       * @param {Object}  options         Options for finish hotfix
       * @return {Commit}   The commit created by finishing the hotfix
       */

    }, {
      key: 'finishHotfix',
      value: function finishHotfix(repo, hotfixVersion) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var keepBranch = options.keepBranch,
            message = options.message,
            processMergeMessageCallback = options.processMergeMessageCallback,
            _options$beforeMergeC = options.beforeMergeCallback,
            beforeMergeCallback = _options$beforeMergeC === undefined ? function () {} : _options$beforeMergeC,
            _options$postDevelopM = options.postDevelopMergeCallback,
            postDevelopMergeCallback = _options$postDevelopM === undefined ? function () {} : _options$postDevelopM,
            _options$postMasterMe = options.postMasterMergeCallback,
            postMasterMergeCallback = _options$postMasterMe === undefined ? function () {} : _options$postMasterMe,
            signingCallback = options.signingCallback;


        if (!repo) {
          return Promise.reject(new Error('Repo is required'));
        }

        if (!hotfixVersion) {
          return Promise.reject(new Error('Hotfix name is required'));
        }

        var developBranchName = void 0;
        var hotfixBranchName = void 0;
        var masterBranchName = void 0;
        var cancelMasterMerge = void 0;
        var cancelDevelopMerge = void 0;
        var developBranch = void 0;
        var hotfixBranch = void 0;
        var masterBranch = void 0;
        var developCommit = void 0;
        var hotfixCommit = void 0;
        var masterCommit = void 0;
        var mergeCommit = void 0;
        var versionPrefix = void 0;
        return Config.getConfig(repo).then(function (config) {
          developBranchName = config['gitflow.branch.develop'];
          hotfixBranchName = config['gitflow.prefix.hotfix'] + hotfixVersion;
          masterBranchName = config['gitflow.branch.master'];
          versionPrefix = config['gitflow.prefix.versiontag'];

          // Get the develop, master, and hotfix branch
          return Promise.all([developBranchName, hotfixBranchName, masterBranchName].map(function (branchName) {
            return NodeGit.Branch.lookup(repo, branchName, NodeGit.Branch.BRANCH.LOCAL);
          }));
        }).then(function (branches) {
          developBranch = branches[0];
          hotfixBranch = branches[1];
          masterBranch = branches[2];

          // Get the commits that the develop, master, and hotfix branches point to
          return Promise.all(branches.map(function (branch) {
            return repo.getCommit(branch.target());
          }));
        }).then(function (commits) {
          developCommit = commits[0];
          hotfixCommit = commits[1];
          masterCommit = commits[2];

          // If either develop or master point to the same commit as the hotfix branch cancel
          // their respective merge
          cancelDevelopMerge = developCommit.id().toString() === hotfixCommit.id().toString();
          cancelMasterMerge = masterCommit.id().toString() === hotfixCommit.id().toString();

          // Merge hotfix into develop
          if (!cancelDevelopMerge) {
            return Promise.resolve(beforeMergeCallback(developBranchName, hotfixBranchName)).then(function () {
              return utils.Repo.merge(developBranch, hotfixBranch, repo, processMergeMessageCallback, signingCallback);
            }).then(utils.InjectIntermediateCallback(postDevelopMergeCallback));
          }
          return Promise.resolve();
        }).then(function (_mergeCommit) {
          mergeCommit = _mergeCommit;

          var tagName = versionPrefix + hotfixVersion;
          // Merge the hotfix branch into master
          if (!cancelMasterMerge) {
            return Promise.resolve(beforeMergeCallback(masterBranchName, hotfixBranchName)).then(function () {
              return utils.Repo.merge(masterBranch, hotfixBranch, repo, processMergeMessageCallback, signingCallback);
            }).then(utils.InjectIntermediateCallback(postMasterMergeCallback)).then(function (oid) {
              return utils.Tag.create(oid, tagName, message, repo);
            });
          }

          // If the merge is cancelled only tag the master commit
          var masterOid = NodeGit.Oid.fromString(masterCommit.id().toString());
          return utils.Tag.create(masterOid, tagName, message, repo);
        }).then(function () {
          if (keepBranch) {
            return Promise.resolve();
          }

          return hotfixBranch.delete();
        }).then(function () {
          return mergeCommit;
        });
      }
    }]);

    return Hotfix;
  }();

  return Hotfix;
};