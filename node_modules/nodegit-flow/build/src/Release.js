'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function (NodeGit, _ref, _ref2) {
  var constants = _ref.constants,
      utils = _ref.utils;
  var Config = _ref2.Config;

  /**
   * All of this class' functions are attached to `NodeGit.Flow` or a `Flow` instance object
   * @class
   */
  var Release = function () {
    function Release(repo) {
      _classCallCheck(this, Release);

      this.repo = repo;
    }

    /**
     * Starts a git flow "release"
     * @async
     * @param {Object}  repo            The repository to start a release in
     * @param {String}  releaseVersion  The version of the release to start
     * @param {Object}  options         Options for start release
     * @return {Branch}   The nodegit branch for the release
     */


    _createClass(Release, [{
      key: 'startRelease',


      /**
       * Starts a git flow "release"
       * @async
       * @param {String}  releaseVersion  The version of the release to start
       * @param {Object}  options         Options for start release
       * @return {Branch}   The nodegit branch for the release
       */
      value: function startRelease() {
        return Release.startRelease.apply(Release, [this.repo].concat(Array.prototype.slice.call(arguments)));
      }

      /**
       * Finishes a git flow "release"
       * @async
       * @param {String}  releaseVersion  The version of the release to finish
       * @param {Object}  options         Options for finish release
       * @return {Commit}   The commit created by finishing the release
       */

    }, {
      key: 'finishRelease',
      value: function finishRelease() {
        return Release.finishRelease.apply(Release, [this.repo].concat(Array.prototype.slice.call(arguments)));
      }
    }], [{
      key: 'startRelease',
      value: function startRelease(repo, releaseVersion) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var sha = options.sha;


        if (!repo) {
          return Promise.reject(new Error(constants.ErrorMessage.REPO_REQUIRED));
        }

        if (!releaseVersion) {
          return Promise.reject(new Error('Release version is required'));
        }

        var releaseBranchName = void 0;
        var releaseBranch = void 0;

        return Config.getConfig(repo).then(function (config) {
          var releasePrefix = config['gitflow.prefix.release'];
          var developBranchName = config['gitflow.branch.develop'];
          releaseBranchName = releasePrefix + releaseVersion;

          // If we have a sha look that up instead of the develop branch
          if (sha) {
            return NodeGit.Commit.lookup(repo, sha);
          }

          return NodeGit.Branch.lookup(repo, developBranchName, NodeGit.Branch.BRANCH.LOCAL).then(function (developBranch) {
            return NodeGit.Commit.lookup(repo, developBranch.target());
          });
        }).then(function (startingCommit) {
          return repo.createBranch(releaseBranchName, startingCommit);
        }).then(function (_releaseBranch) {
          releaseBranch = _releaseBranch;
          return repo.checkoutBranch(releaseBranch);
        }).then(function () {
          return releaseBranch;
        });
      }

      /**
       * Finishes a git flow "release"
       * @async
       * @param {Object}  repo            The repository to finish a release in
       * @param {String}  releaseVersion  The version of the release to finish
       * @param {Object}  options         Options for finish release
       * @return {Commit}   The commit created by finishing the release
       */

    }, {
      key: 'finishRelease',
      value: function finishRelease(repo, releaseVersion) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var keepBranch = options.keepBranch,
            message = options.message,
            processMergeMessageCallback = options.processMergeMessageCallback,
            _options$beforeMergeC = options.beforeMergeCallback,
            beforeMergeCallback = _options$beforeMergeC === undefined ? function () {} : _options$beforeMergeC,
            _options$postDevelopM = options.postDevelopMergeCallback,
            postDevelopMergeCallback = _options$postDevelopM === undefined ? function () {} : _options$postDevelopM,
            _options$postMasterMe = options.postMasterMergeCallback,
            postMasterMergeCallback = _options$postMasterMe === undefined ? function () {} : _options$postMasterMe,
            signingCallback = options.signingCallback;


        if (!repo) {
          return Promise.reject(new Error('Repo is required'));
        }

        if (!releaseVersion) {
          return Promise.reject(new Error('Release name is required'));
        }

        var developBranchName = void 0;
        var releaseBranchName = void 0;
        var masterBranchName = void 0;
        var developBranch = void 0;
        var releaseBranch = void 0;
        var masterBranch = void 0;
        var cancelDevelopMerge = void 0;
        var cancelMasterMerge = void 0;
        var developCommit = void 0;
        var releaseCommit = void 0;
        var masterCommit = void 0;
        var mergeCommit = void 0;
        var versionPrefix = void 0;
        return Config.getConfig(repo).then(function (config) {
          developBranchName = config['gitflow.branch.develop'];
          releaseBranchName = config['gitflow.prefix.release'] + releaseVersion;
          masterBranchName = config['gitflow.branch.master'];
          versionPrefix = config['gitflow.prefix.versiontag'];

          // Get the develop, master, and release branch
          return Promise.all([developBranchName, releaseBranchName, masterBranchName].map(function (branchName) {
            return NodeGit.Branch.lookup(repo, branchName, NodeGit.Branch.BRANCH.LOCAL);
          }));
        }).then(function (branches) {
          developBranch = branches[0];
          releaseBranch = branches[1];
          masterBranch = branches[2];

          // Get the commits that the develop, master, and release branches point to
          return Promise.all(branches.map(function (branch) {
            return repo.getCommit(branch.target());
          }));
        }).then(function (commits) {
          developCommit = commits[0];
          releaseCommit = commits[1];
          masterCommit = commits[2];

          // If either develop or master point to the same commit as the release branch cancel
          // their respective merge
          cancelDevelopMerge = developCommit.id().toString() === releaseCommit.id().toString();
          cancelMasterMerge = masterCommit.id().toString() === releaseCommit.id().toString();

          // Merge release into develop
          if (!cancelDevelopMerge) {
            return Promise.resolve(beforeMergeCallback(developBranchName, releaseBranchName)).then(function () {
              return utils.Repo.merge(developBranch, releaseBranch, repo, processMergeMessageCallback, signingCallback);
            }).then(utils.InjectIntermediateCallback(postDevelopMergeCallback));
          }
          return Promise.resolve();
        }).then(function (_mergeCommit) {
          mergeCommit = _mergeCommit;

          var tagName = versionPrefix + releaseVersion;
          // Merge the release branch into master
          if (!cancelMasterMerge) {
            return Promise.resolve(beforeMergeCallback(masterBranchName, releaseBranchName)).then(function () {
              return utils.Repo.merge(masterBranch, releaseBranch, repo, processMergeMessageCallback, signingCallback);
            }).then(utils.InjectIntermediateCallback(postMasterMergeCallback)).then(function (oid) {
              return utils.Tag.create(oid, tagName, message, repo);
            });
          }

          var masterOid = NodeGit.Oid.fromString(masterCommit.id().toString());
          return utils.Tag.create(masterOid, tagName, message, repo);
        }).then(function () {
          if (keepBranch) {
            return Promise.resolve();
          }

          return releaseBranch.delete();
        }).then(function () {
          return mergeCommit;
        });
      }
    }]);

    return Release;
  }();

  return Release;
};