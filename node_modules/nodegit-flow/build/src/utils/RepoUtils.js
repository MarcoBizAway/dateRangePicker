'use strict';

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

module.exports = function (NodeGit, MergeUtils) {
  return {
    merge: function merge(toBranch, fromBranch, repo) {
      var processMergeMessageCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (a) {
        return a;
      };
      var signingCallback = arguments[4];

      return Promise.resolve().then(function () {
        if (!toBranch.isHead()) {
          return repo.checkoutBranch(toBranch);
        }
        return Promise.resolve();
      }).then(function () {
        return NodeGit.AnnotatedCommit.fromRef(repo, fromBranch);
      }).then(function (fromCommit) {
        var checkoutOpts = {
          checkoutStrategy: NodeGit.Checkout.STRATEGY.SAFE | NodeGit.Checkout.STRATEGY.RECREATE_MISSING
        };
        return NodeGit.Merge.merge(repo, fromCommit, null, checkoutOpts);
      }).then(function () {
        return repo.index();
      }).then(function (index) {
        if (index.hasConflicts && index.hasConflicts()) {
          return Promise.reject(index);
        }

        return index.writeTree();
      }).then(function (treeOid) {
        return Promise.all([treeOid, processMergeMessageCallback(MergeUtils.getMergeMessage(toBranch, fromBranch)), repo.defaultSignature(), repo.getHeadCommit(), repo.getBranchCommit('MERGE_HEAD')]);
      }).then(function (_ref) {
        var _ref2 = _toArray(_ref),
            treeOid = _ref2[0],
            message = _ref2[1],
            signature = _ref2[2],
            commits = _ref2.slice(3);

        return signingCallback ? repo.createCommitWithSignature('HEAD', signature, signature, message, treeOid, commits, signingCallback) : repo.createCommit('HEAD', signature, signature, message, treeOid, commits);
      }).then(function (commitId) {
        repo.stateCleanup();

        return commitId;
      });
    },
    rebase: function rebase(toBranch, fromBranch, repo, beforeRebaseFinish, signingCallback) {
      return repo.rebaseBranches(fromBranch.name(), toBranch.name(), undefined, undefined, undefined, beforeRebaseFinish, {
        signingCb: signingCallback
      }).then(function (result) {
        if (result.hasConflicts && result.hasConflicts()) {
          return Promise.reject(result);
        }

        return toBranch.setTarget(result, '');
      });
    }
  };
};